/*************************************************************************
 * tcpsock.c
 *
 *  tcpsock = Transport Control Protocol, Socket
 *  Project: eZ2944
 *************************************************************************/
#include <stdio.h>
#include <string.h>
#include "project.h"
#include "bmz.h"
#include "tcpip.h"
#include "checksum.h"
#include "ether.h"      // for ether_rx_room()
#include "tcpsock.h"

// TCP applications can hook this function for special features (eg
//  TSERVER app uses it to setup uart according to the port specified
//  by the remote user)
extern bool tcpapp_listen_callback( u16 listen_port, u16 loc_port );

// TCP state
typedef enum
{
    ST_CLOSED,
    ST_LISTEN,
    ST_SYN_RECVD,
    ST_SYN_SENT,
    ST_ESTABLISHED,
    ST_CLOSE_WAIT,
    ST_LASTACK,
    ST_FIN_WAIT1,
    ST_FIN_WAIT2,
    ST_CLOSING,
    ST_TIMED_WAIT
} STATE;

// Events to apply to TCP state machine
typedef enum
{
    EV_NULL,
    EV_OPEN_PASSIVE,
    EV_OPEN_ACTIVE,
    EV_RX_SYN,
    EV_RX_ACK,
    EV_RX_SYN_ACK,
    EV_RX_FIN,
    EV_RX_FIN_ACK,
    EV_RX_RESET,
    EV_CLOSE,
    EV_SEND,
    EV_TIMEOUT
} EVENT;

// Actions generated by TCP state machine
typedef enum
{
    ACT_NULL,
    ACT_TX_SYN,
    ACT_TX_ACK,
    ACT_TX_SYN_ACK,
    ACT_TX_FIN,
    ACT_TX_RESET,
    ACT_TX_NEW_DATA,
    ACT_TX_RETRY
} ACTION;

// Misc
#define WINDOW_RX   1000
#define TIMER_2MSL  60
#define TX_BUF_SIZE 1000

// Timer IDs
#define TIMER_ID_RETRY       0
#define TIMER_ID_DELAYED_ACK 1

// In receive direction, ack syn then data then fin
typedef enum
{
    ACK_IDLE,
    ACK_SYN,
    ACK_DATA,
    ACK_FIN
} ACK_PHASE;

// TX states
#define IS_TX_STATE(state) (is_tx_state[(state)])
static const bool is_tx_state[] =
{
    false,  // ST_CLOSED
    false,  // ST_LISTEN
    false,  // ST_SYN_RECVD
    false,  // ST_SYN_SENT
    true,   // ST_ESTABLISHED
    true,   // ST_CLOSE_WAIT
    false,  // ST_LASTACK
    false,  // ST_FIN_WAIT1
    false,  // ST_FIN_WAIT2
    false,  // ST_CLOSING
    false   // ST_TIMED_WAIT
};

// RX states
#define IS_RX_STATE(state) (is_rx_state[(state)])
static const bool is_rx_state[] =
{
    false,  // ST_CLOSED
    false,  // ST_LISTEN
    false,  // ST_SYN_RECVD
    false,  // ST_SYN_SENT
    true,   // ST_ESTABLISHED
    false,  // ST_CLOSE_WAIT
    false,  // ST_LASTACK
    true,   // ST_FIN_WAIT1
    true,   // ST_FIN_WAIT2
    false,  // ST_CLOSING
    false   // ST_TIMED_WAIT
};

// Progressively increase timeout if no reply
static const u16 backoff_array[] =
{
    1, 2, 4, 8, 16, 32, 64, 128
};

// Module data
typedef struct
{
    byte        state;
    byte        ack_phase;
    bool        send_ack;
    TIMER       timer_retry;
    TIMER       timer_delayed_ack;
    bool        delayed_ack_pending;
    TASKID      taskid_app;
    u16         tx_size;
    byte       *tx_buf;
    byte       *tx_get;
    byte       *tx_put;
    byte       *tx_end;
    u32         tx_seq;
    u32         rx_seq;
    u16         tx_unacked;
    u16         tx_window;
    u32         ack_plus_window;
    byte        backoff_index;
    u16         loc_port;
    u16         rem_port;
    IPADDR      rem_ipaddr;
    u32         rtt_rto_previous;
    u32         rtt_estimate;
    u32         rtt_mean_deviation;
    bool        rtt_updated;
    bool        rtt_retry_pending;
    u32         rtt_start_time;
    bool        tx_push;
} TCPSOCK;

// Local prototypes
static void tcpsock_reset( TCPSOCK *z );
static ACTION connection_state_machine( TCPSOCK *z, EVENT event );
static void tx_process( TCPSOCK *z, ACTION action );
static void rtt_calculation( TCPSOCK *z, u32 sample );

/*************************************************************************
 * Init
 *************************************************************************/
void *tcpsock_init( byte **addr_mem, u16 *addr_len )
{
    TCPSOCK *z;
    byte    *memory = *addr_mem;
    u16     memlen  = *addr_len;

    // Allocate module memory
    if( memlen < sizeof(TCPSOCK) )
        bmz_panic_memory("tcpsock");
    else
    {
        z        = (TCPSOCK *)memory;
        memory  += sizeof(TCPSOCK);
        memlen  -= sizeof(TCPSOCK);
        z->tx_size = TX_BUF_SIZE;
        if( memlen < z->tx_size )
            bmz_panic_memory("tcpsock");
        else
        {
            z->tx_buf = (byte *)memory;
            memory  += z->tx_size;
            memlen  -= z->tx_size;
            tcpsock_reset( z );
        }
    }
    *addr_mem = memory;
    *addr_len = memlen;
    return( z );
}


/*************************************************************************
 * Message down
 *************************************************************************/
// Message format in (down from APP);
//      [MSG_TYPE_OPEN_ACTIVE] [loc port,2][rem port,2][rem ipaddr]
//   OR [MSG_TYPE_OPEN_PASSIVE][loc_port,2]
//   OR [MSG_TYPE_DATA]        [user data]
//   OR [MSG_TYPE_CLOSE]
// Message format out (down to TCP);
//      [dst_ipaddr,4]
//      [src_port,2]
//      [dst_port,2]
//      [seq_nbr,4]
//      [ack_nbr,4]
//      [code_bits,2]
//      [window,2]
//      [user data]
void tcpsock_down( MSG *msg )
{
    TCPSOCK *z = bmz_get_current_instance();
    ACTION action = ACT_NULL;
    u16  phase1, tx_room;
    bool processed=true;

    // Take off message type
    byte msg_type = msg_pop1(msg);
    switch( msg_type )
    {

        // Client style OPEN
        case MSG_TYPE_OPEN_ACTIVE:
        {
            action = connection_state_machine( z, EV_OPEN_ACTIVE );
            if( action == ACT_TX_SYN )
            {
                z->loc_port   = msg_pop2(msg);
                z->rem_port   = msg_pop2(msg);
                z->rem_ipaddr = msg_pop4(msg);
            }
            break;
        }

        // Server style OPEN
        case MSG_TYPE_OPEN_PASSIVE:
        {
            action = connection_state_machine( z, EV_OPEN_PASSIVE );
            if( z->state == ST_LISTEN )
                z->loc_port   = msg_pop2(msg);
            break;
        }

        // Data to send
        case MSG_TYPE_DATA:      z->tx_push = false;  // and fall through
        case MSG_TYPE_DATA_PUSH: if( msg_type==MSG_TYPE_DATA_PUSH )
                                    z->tx_push = true;
        {
            if( IS_TX_STATE(z->state) )
            {

                // Calculate room in tx buffer
                if( z->tx_put >= z->tx_get )
                    tx_room = z->tx_size-(z->tx_put-z->tx_get)-1;
                else
                    tx_room = z->tx_get-z->tx_put-1;

                // If not enough room, push the message back on the queue
                if( msg_len(msg) > tx_room )
                {
                    MQ *mq = bmz_get_mq_down( bmz_get_current_taskid() );
                    if( mq )
                    {
                        printf( "@" );
                        mq_pushback( mq, msg );
                        processed = false;
                        action = ACT_TX_NEW_DATA; // better try and send!
                    }
                }

                // Else copy to buffer, in 1 step or 2 (if wraparound)
                else
                {
                    phase1 = z->tx_end-z->tx_put;
                    if( phase1 >= msg_len(msg) )
                    {
                        memcpy( z->tx_put, msg_ptr(msg), msg_len(msg) );
                        z->tx_put += msg_len(msg);
                        if( z->tx_put == z->tx_end )
                            z->tx_put = z->tx_buf;
                    }
                    else
                    {
                        memcpy( z->tx_put, msg_ptr(msg), phase1 );
                        memcpy( z->tx_buf, msg_ptr(msg)+phase1,
                                                     msg_len(msg)-phase1 );
                        z->tx_put = z->tx_buf + (msg_len(msg)-phase1);
                    }

                    // If there is no unacknowledged data, send immediately
                    if( z->tx_unacked == 0 )
                        action = ACT_TX_NEW_DATA;
                }
            }
            break;
        }

        // Close, user should check that published state leaves PUBLISH_ACTIVE,
        //  otherwise close has been rejected because till sending data
        //  (note this is 'client' functionality, not yet tested in the
        //   terminal server project)
        case MSG_TYPE_CLOSE:
        {
            if( z->tx_unacked == 0 )
                action = connection_state_machine( z, EV_CLOSE );
            break;
        }

        // Close immediately
        //  (note this is 'client' functionality, not yet tested in
        //  the terminal server project)
        case MSG_TYPE_ABORT:
        {
            action = ACT_TX_RESET;
            break;
        }
    }

    // Free message
    if( processed )
        msg_free(msg);

    // Transmit if appropriate
    if( action != ACT_NULL )
        tx_process( z, action );
    if( action == ACT_TX_RESET )
        tcpsock_reset(z);
}

/*************************************************************************
 * Message up
 *************************************************************************/
// Message format in (up from TCP);
//      [seq_nbr,4]
//      [ack_nbr,4]
//      [code_bits,2]
//      [window,2]
//      [user data]
// Message format out (up to APP);
//      [MSG_TYPE_DATA] [user data]
//   OR [MSG_TYPE_CLOSE]
void tcpsock_up( MSG *msg )
{
    TCPSOCK *z = bmz_get_current_instance();
    byte oldstate;
    ACTION action;
    EVENT event=EV_NULL;
    bool discard=true;
    bool stop=false;        // stop retry timer ?

    // Take off the parameters
    u32 seq_nbr   = msg_pop4(msg);
    u32 ack_nbr   = msg_pop4(msg);
    u16 code_bits = msg_pop2(msg);
    u16 window    = msg_pop2(msg);

    // Validate ACK_BIT against valid ack_nbr
    if( code_bits & ACK_BIT )
    {
        z->rtt_updated = false; // last ack updated rtt ?
        switch( z->ack_phase )
        {
            case ACK_IDLE:
            {
                code_bits &= ~ACK_BIT;
                break;
            }
            case ACK_SYN:
            {
                if( ack_nbr == z->tx_seq+1 )
                {
                    z->ack_phase = ACK_DATA;
                    z->tx_unacked = 0;
                    z->tx_seq++;
                    z->tx_window  = window;
                    stop = true;
                }
                else
                    code_bits &= ~ACK_BIT;
                break;
            }
            case ACK_FIN:
            {
                if( ack_nbr == z->tx_seq+1 )
                {
                    z->ack_phase = ACK_IDLE;
                    z->tx_seq++;
                    z->tx_window = window;
                    stop = true;
                }
                else
                    code_bits &= ~ACK_BIT;
                break;
            }
            case ACK_DATA:
            {
                long nbr_acked = (long)(ack_nbr-z->tx_seq); // cast to signed
                if( nbr_acked > z->tx_unacked )
                    code_bits &= ~ACK_BIT;
                else
                {
                    if( nbr_acked > 0 )
                    {

                        // Remove data from buffer
                        z->tx_seq     += nbr_acked;
                        z->tx_unacked -= (u16)nbr_acked;
                        z->tx_window   = window;
                        z->tx_get     += nbr_acked;
                        if( z->tx_get >= z->tx_end )
                            z->tx_get = z->tx_buf + (z->tx_get-z->tx_end);
                        if( !z->rtt_retry_pending )
                        {
                            u32 sample = tick_get()-z->rtt_start_time;
                            rtt_calculation( z, sample );
                            z->rtt_updated = true;
                            z->backoff_index = 0;
                        }
                        if( z->tx_unacked == 0 )
                            stop = true;
                    }
                }
                break;
            }
        }
        if( stop )
            timer_stop( &z->timer_retry );
    }

    // Validate FIN_BIT against valid seq_nbr
    if( code_bits & FIN_BIT )
    {
        if( z->rx_seq != seq_nbr )
            code_bits &= ~FIN_BIT;
    }

    // Generate RX events
    if( code_bits & RST_BIT )
        event = EV_RX_RESET;
    else if( (code_bits&(SYN_BIT|ACK_BIT)) == (SYN_BIT|ACK_BIT) )
        event = EV_RX_SYN_ACK;
    else if( (code_bits&(FIN_BIT|ACK_BIT)) == (FIN_BIT|ACK_BIT) )
        event = EV_RX_FIN_ACK;
    else if( code_bits & FIN_BIT )
        event = EV_RX_FIN;
    else if( code_bits & SYN_BIT )
        event = EV_RX_SYN;
    else if( code_bits & ACK_BIT )
        event = EV_RX_ACK;

    // Process RX event
    oldstate = z->state;
    action = connection_state_machine( z, event );

    // If a SYN event was valid, it would generate a state change, if so
    //  initialise the rx_seq nbr
    if( oldstate != z->state && (event==EV_RX_SYN||event==EV_RX_SYN_ACK) )
    {
        z->rx_seq = seq_nbr+1;
        z->ack_plus_window = z->rx_seq;
    }

    // If a FIN event was valid, it would generate a state change, if so
    //  bump rx_seq nbr
    else if( oldstate != z->state && (event==EV_RX_FIN||event==EV_RX_FIN_ACK) )
        z->rx_seq++;

    // Send close up to app
    if( oldstate!=z->state && z->state==ST_LASTACK )
    {
        discard = false;
        msg_clear( msg );
        msg_push1( msg, MSG_TYPE_CLOSE );
        bmz_up( z->taskid_app, msg );
    }

    // Send valid data received up to app
    else if( IS_RX_STATE(oldstate) )
    {
        if( z->rx_seq==seq_nbr && msg_len(msg) )
        {
            z->rx_seq += msg_len(msg);
            discard = false;
            msg_push1( msg, MSG_TYPE_DATA );
            bmz_up( z->taskid_app, msg );
            if( !timer_running(&z->timer_delayed_ack) )
                timer_start_ticks( &z->timer_delayed_ack, 3 );
            z->delayed_ack_pending = true;
        }
        else if( z->rx_seq!=seq_nbr )
        {
            action = ACT_TX_ACK;
            printf( "* Wrong RX sequence number! *\n" );
        }
    }

    // If we stopped the retry timer, we need to send any new data
    //  we have now
    if( action==ACT_NULL && stop && z->tx_get!=z->tx_put )
        action = ACT_TX_NEW_DATA;

    // If action required, do it
    if( action != ACT_NULL )
    {

        // Do all sending here
        tx_process( z, action );
    }

    // Discard message if not passed on
    if( discard )
        msg_free(msg);
}

/*************************************************************************
 * Timeout
 *************************************************************************/
void tcpsock_timeout( byte timer_id )
{
    TCPSOCK *z = bmz_get_current_instance();
    if( timer_id == TIMER_ID_RETRY )
    {
        #ifdef DEBUG_TCP_TIMEOUT
        printf( "TCP timer expired\n" );
        #endif
        if( z->state == ST_TIMED_WAIT )
            tcpsock_reset(z);
        else
            tx_process( z, ACT_TX_RETRY );
    }
    else if( timer_id == TIMER_ID_DELAYED_ACK )
    {
        #ifdef DEBUG_TCP_DELAYED_ACK_TIMEOUT
        printf( "TCP delayed ack timer expired\n" );
        #endif
        if( z->delayed_ack_pending )
            tx_process( z, ACT_TX_ACK );
    }
}

/*************************************************************************
 * Select a TCPSOCK task in response to an incoming TCP segment
 *************************************************************************/
TASKID tcpsock_select( u16 loc_port, u16 rem_port, IPADDR rem_ipaddr )
{
    int i;
    TASKID taskid, found=TASKID_NULL;
    TCPSOCK *z;
    for( i=0, taskid=TASKID_TCPSOCK1; i<2 && found==TASKID_NULL;
                                             i++, taskid=TASKID_TCPSOCK2 )
    {
        z = bmz_get_instance(taskid);
        if( z->state == ST_LISTEN )
        {
            if( tcpapp_listen_callback(z->loc_port,loc_port) )
            {
                found = taskid;
                z->loc_port   = loc_port;
                z->rem_port   = rem_port;
                z->rem_ipaddr = rem_ipaddr;
            }
            else if( z->loc_port==loc_port )
            {
                found = taskid;
                z->rem_port   = rem_port;
                z->rem_ipaddr = rem_ipaddr;
            }
        }
        else
        {
            if( z->loc_port    == loc_port &&
                z->rem_port    == rem_port &&
                z->rem_ipaddr  == rem_ipaddr
              )
                found = taskid;
        }
    }
    return( found );
}

/*************************************************************************
 * The classic TCP connection state machine
 *************************************************************************/
static ACTION connection_state_machine( TCPSOCK *z, EVENT event )
{
    STATE state=z->state, oldstate=z->state;
    ACTION action=ACT_NULL;
    switch( oldstate )
    {
        case ST_CLOSED:
        {
            if( event == EV_OPEN_PASSIVE )
                state  = ST_LISTEN;
            else if( event == EV_OPEN_ACTIVE )
            {
                action = ACT_TX_SYN;
                state  = ST_SYN_SENT;
            }
            else
                action = ACT_TX_RESET;
            break;
        }
        case ST_LISTEN:
        {
            if( event == EV_RX_SYN )
            {
                action = ACT_TX_SYN_ACK;
                state  = ST_SYN_RECVD;
            }
            else if( event == EV_CLOSE )
                state  = ST_CLOSED;
            else if( event == EV_SEND )
            {
                action = ACT_TX_SYN;
                state  = ST_SYN_SENT;
            }
            break;
        }
        case ST_SYN_RECVD:
        {
            if( event == EV_RX_RESET )
            {
                state = ST_LISTEN;
                z->ack_phase = ACK_IDLE;    // only time we go back to listen
                z->send_ack  = false;
            }
            else if( event == EV_RX_ACK )
                state = ST_ESTABLISHED;
            else if( event == EV_CLOSE )
            {
                action = ACT_TX_FIN;
                state = ST_FIN_WAIT1;
            }
            break;
        }
        case ST_SYN_SENT:
        {
            if( event == EV_RX_SYN )
            {
                action = ACT_TX_SYN_ACK;
                state  = ST_SYN_RECVD;
            }
            else if( event == EV_RX_SYN_ACK )
            {
                action = ACT_TX_ACK;
                state = ST_ESTABLISHED;
            }
            else if( event==EV_CLOSE || event==EV_TIMEOUT )
            {
                action = ACT_TX_RESET;
                state = ST_CLOSED;
            }
            break;
        }
        case ST_ESTABLISHED:
        {
            if( event == EV_CLOSE )
            {
                action = ACT_TX_FIN;
                state  = ST_FIN_WAIT1;
            }
            else if( event==EV_RX_FIN || event==EV_RX_FIN_ACK )
            {
                // No need to support half-close, so auto close
              //action = ACT_TX_ACK;
              //state  = ST_CLOSE_WAIT;
                action = ACT_TX_FIN;
                state  = ST_LASTACK;
            }
            break;
        }
        case ST_CLOSE_WAIT:
        {
            if( event == EV_CLOSE )
            {
                action = ACT_TX_FIN;
                state  = ST_LASTACK;
            }
            break;
        }
        case ST_LASTACK:
        {
            if( event==EV_RX_ACK || event==EV_TIMEOUT )
                state = ST_CLOSED;
            break;
        }
        case ST_FIN_WAIT1:
        {
            if( event == EV_RX_ACK )
                state = ST_FIN_WAIT2;
            else if( event == EV_RX_FIN )
            {
                action = ACT_TX_ACK;
                state  = ST_CLOSING;
            }
            else if( event == EV_RX_FIN_ACK )
            {
                action = ACT_TX_ACK;
                state  = ST_TIMED_WAIT;
            }
            break;
        }
        case ST_FIN_WAIT2:
        {
            if( event==EV_RX_FIN || event==EV_RX_FIN_ACK )
            {
                action = ACT_TX_ACK;
                state  = ST_TIMED_WAIT;
            }
            break;
        }
        case ST_CLOSING:
        {
            if( event == EV_RX_ACK )
                state  = ST_TIMED_WAIT;
            break;
        }
        case ST_TIMED_WAIT:
        {
            if( event == EV_TIMEOUT )
                state = ST_CLOSED;
            break;
        }
    }

    // Perform state entry functions
    if( state != oldstate )
    {
        PUBLISH_STATE publish_state;
        if( state == ST_CLOSED )
            publish_state = PUBLISH_IDLE;
        else if( IS_RX_STATE(state) && IS_TX_STATE(state) )
            publish_state = PUBLISH_ACTIVE;
        else
            publish_state = PUBLISH_OTHER;
        bmz_set_publish_state( publish_state );
        switch( state )
        {
            case ST_CLOSED:
            {
                tcpsock_reset(z);
                break;
            }
            case ST_TIMED_WAIT:
            {
                timer_start_seconds( &z->timer_retry, TIMER_2MSL );
                break;
            }
        }
    }
    z->state = state;
    return( action );
}


/*************************************************************************
 * Do all TX
 *************************************************************************/
static void tx_process( TCPSOCK *z, ACTION action )
{
    static u32 nbr_connections;
    MSG *msg;
    u16  timeout, nbr, nbr_sent=0, phase1, window, code_bits;
    u32  ack_nbr, tx_seq;
    byte *get;
    long temp;
    bool wait_for_later=false;
    bool send_rst =false;
    bool send_syn =false;
    bool send_fin =false;
    bool send_data=false;

    // Is it time to send data ?
    if( z->ack_phase == ACK_DATA   &&
        z->tx_get    != z->tx_put  &&
        (action==ACT_TX_NEW_DATA || action==ACT_TX_RETRY || z->tx_unacked==0)
      )
    {
        send_data = true;
        if( z->tx_unacked == 0 )
        {
            z->rtt_start_time    = tick_get();
            z->rtt_retry_pending = false;
        }
        else
            z->rtt_retry_pending = true;
    }

    // Work out what (else) to send
    switch( action )
    {
        case ACT_TX_SYN_ACK:
            z->send_ack   = true;               // and fall through
        case ACT_TX_SYN:
        {
            z->ack_phase  = ACK_SYN;
            send_data     = false;
            send_syn      = true;
            z->tx_seq     = (++nbr_connections) *
                            tick_get_hi_res();  // establish tx_seq
            break;
        }
        case ACT_TX_RESET:
        {
            send_data     = false;
            send_rst      = true;
            break;
        }
        case ACT_TX_FIN:
        {
            z->ack_phase  = ACK_FIN;
            send_fin      = true;
            send_data     = false;
            break;
        }
        case ACT_TX_ACK:
        {
            z->send_ack   = true;
            break;
        }
        case ACT_TX_RETRY:
        {
            if( z->ack_phase == ACK_SYN )
                send_syn  = true;
            else if( z->ack_phase == ACK_FIN )
                send_fin  = true;
            break;
        }
        case ACT_TX_NEW_DATA:
        {
            if( z->tx_window == 0 )
                wait_for_later=true;
            break;
        }
    }

    // Is there something to send ?
    if( !wait_for_later &&
        (z->send_ack || send_syn || send_fin || send_rst || send_data)
      )
    {

        // Use a temporary copy of tx_get because we don't actually take
        //  data out of the buffer
        get    = z->tx_get;
        tx_seq = z->tx_seq;

        // Loop enables multiple send_data operations
        do
        {
            msg = pool_alloc( bmz_get_current_pool() );
            if( !msg )
                break;  // normal TCP procedures will retry
            if( send_data )
            {
                if( z->tx_put >= get )
                    nbr = z->tx_put-get;
                else
                    nbr = z->tx_size - (get-z->tx_put);
                if( nbr > (z->tx_window-nbr_sent) )
                    nbr = (z->tx_window-nbr_sent);
                if( nbr > msg_room(msg) )
                    nbr = msg_room(msg);
                else
                    send_data = false;  // no more to send
                phase1 = z->tx_end-get;
                if( phase1 >= nbr )
                {
                    memcpy( msg_ptr(msg), get, nbr );
                    get += nbr;
                    if( get == z->tx_end )
                        get = z->tx_buf;
                }
                else
                {
                    memcpy( msg_ptr(msg), get, phase1 );
                    memcpy( msg_ptr(msg)+phase1, z->tx_buf, nbr-phase1 );
                    get = z->tx_buf + nbr-phase1;
                }
                msg_len(msg) += nbr;    // assumes msg_len() is a macro
                nbr_sent     += nbr;
            }

            // Message format out (down to TCP);
            //      [dst_ipaddr,4]
            //      [src_port,2]
            //      [dst_port,2]
            //      [seq_nbr,4]
            //      [ack_nbr,4]
            //      [code_bits,2]
            //      [window,2]
            //      [user data]
            if( !z->send_ack )
            {
                window = 0;
                ack_nbr = 0;
            }
            else
            {
                // Make sure combination of ack_nbr and window never becomes
                //  more negative, i.e. don't contradict previous indications
                ack_nbr = z->rx_seq;
                if( ether_rx_room() > 2*WINDOW_RX )
                    window = WINDOW_RX;
                else
                {
                    window = (u16)(z->ack_plus_window - ack_nbr);
                    if( window<0 ||  window>WINDOW_RX )
                        window = 0;
                }
                temp = (ack_nbr+window - z->ack_plus_window);
                if( temp >= 0 )
                    z->ack_plus_window = ack_nbr+window;
            }

            // Code bits
            code_bits = 0;
            if( send_syn )
                code_bits |= SYN_BIT;
            if( send_fin )
            {
                code_bits |= FIN_BIT;
                window = 0;
            }
            if( send_rst )
            {
                code_bits |= RST_BIT;
                window = 0;
            }
            if( z->send_ack )
                code_bits |= ACK_BIT;
            if( nbr_sent && z->tx_push )
                code_bits |= PSH_BIT;

            // Add parameters
            msg_push2( msg, window );
            msg_push2( msg, code_bits );
            msg_push4( msg, ack_nbr );
            msg_push4( msg, tx_seq  );
            tx_seq += nbr_sent;
            msg_push2( msg, z->rem_port );
            msg_push2( msg, z->loc_port );
            msg_push4( msg, z->rem_ipaddr );
            bmz_down( TASKID_TCP, msg );
            z->delayed_ack_pending = false;
        }
        while( send_data );
        z->tx_unacked = nbr_sent;
    }

    // Make sure a retry is really pending
    if( nbr_sent == 0 )
        z->rtt_retry_pending = false;

    // Do we expect acknowlegement ?
    if( z->ack_phase==ACK_SYN || z->ack_phase==ACK_FIN ||
        ( z->ack_phase==ACK_DATA && (z->tx_get!=z->tx_put)  )
      )
    {

        // Don't restart the timer - it can delay retries
        //  indefinitely
        if( !timer_running(&z->timer_retry) )
        {

            // Calculate timeout according to following formula;
            //  Timeout = RTT + 4*MD
            // RTT = round trip time estimate
            // MD  = mean deviation of samples used for rtt calculation
            if( z->rtt_updated )
            {
                timeout = (u16)(z->rtt_estimate + (z->rtt_mean_deviation<<2));
                z->rtt_rto_previous = timeout;
            }

            // But if last ack didn't update rtt, retain current value of
            //  timeout instead
            else
                timeout = (u16)z->rtt_rto_previous;

            // And multiply by a backoff factor
            if( z->backoff_index < 0 )
                z->backoff_index = 0;
            else if( z->backoff_index >= nbrof(backoff_array) )
                z->backoff_index = nbrof(backoff_array)-1;
            timeout *= backoff_array[z->backoff_index++];
            #ifdef DEBUG_TCP_START_RETRY
            printf( "%u ticks, rtt=%u, md=%u\n", (u16)timeout+1,
                         (u16)z->rtt_estimate, (u16)z->rtt_mean_deviation );
            #endif
            timer_start_ticks( &z->timer_retry, (u32)timeout+1 ); //round up
        }
    }
}

/*************************************************************************
 * Initialize variables
 *************************************************************************/
static void tcpsock_reset( TCPSOCK *z )
{
    z->state = ST_CLOSED;
    z->tx_get = z->tx_buf;
    z->tx_put = z->tx_buf;
    z->tx_end = z->tx_buf+z->tx_size;
    z->state = ST_CLOSED;
    timer_reset( &z->timer_retry,       TIMER_ID_RETRY );
    timer_reset( &z->timer_delayed_ack, TIMER_ID_DELAYED_ACK );
    if( bmz_get_current_taskid() == TASKID_TCPSOCK1 )
        z->taskid_app = TASKID_TCPAPP1;
    else
        z->taskid_app = TASKID_TCPAPP2;
    z->tx_seq               = 0;
    z->rx_seq               = 0;
    z->tx_unacked           = 0;
    z->tx_window            = 0;
    z->ack_plus_window      = 0;
    z->backoff_index        = 0;
    z->loc_port             = 0;
    z->rem_port             = 0;
    z->rem_ipaddr           = 0;
    z->ack_phase            = ACK_IDLE;
    z->send_ack             = false;
    z->delayed_ack_pending  = false;
    z->rtt_rto_previous     = SECS_TO_TICKS(1);
    z->rtt_estimate         = SECS_TO_TICKS(1);
    z->rtt_mean_deviation   = SECS_TO_TICKS(0);
    z->rtt_updated          = false;
    z->rtt_retry_pending    = false;
    z->rtt_start_time       = 0;
    z->tx_push              = false;
    bmz_set_publish_state( PUBLISH_IDLE );
}


/*************************************************************************
 * Calculate smoothed estimate of RTT (round trip time) and MD (mean
 *  devaition)
 *************************************************************************/
static void rtt_calculation( TCPSOCK *z, u32 sample )
{
    long error;
    u32  deviation;

    // Error = difference between the sample and the current
    //  estimate, positive if sample is longer
    error = (long)(sample-z->rtt_estimate);

    // Update the estimate (RTT = RTT + error/8)
    z->rtt_estimate = z->rtt_estimate + (error>>3);

    // Don't let it get unreasonably small
    if( (long)(z->rtt_estimate) < 2 )
        z->rtt_estimate = 2;

    // Now taking the absolute value of the error gives a sample
    //  of the mean deviation
    if( error < 0 )
        deviation = (u32)(0-error);
    else
        deviation = (u32)(error);

    // Error = difference between the sample and the current
    //  estimate, positive if sample is longer
    error = (long)(deviation-z->rtt_mean_deviation);

    // Update the estimate (MD = MD + error/4)
    z->rtt_mean_deviation = z->rtt_mean_deviation + (error>>2);

    // Don't let it get zero or negative
    if( (long)(z->rtt_mean_deviation) < 1 )
        z->rtt_mean_deviation = 1;
}
